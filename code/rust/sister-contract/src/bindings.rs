// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod brother {
    pub mod guest {
        /// * ───── shared definitions ───── */
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod common {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct Header {
                pub key: _rt::String,
                pub value: _rt::String,
            }
            impl ::core::fmt::Debug for Header {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Header")
                        .field("key", &self.key)
                        .field("value", &self.value)
                        .finish()
                }
            }
            pub type Headers = _rt::Vec<Header>;
            pub type SubId = u64;
            /// * strong-ids */
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Ckey {
                pub id: u64,
            }
            impl ::core::fmt::Debug for Ckey {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ckey").field("id", &self.id).finish()
                }
            }
            #[derive(Clone)]
            pub struct Fkey {
                pub contract: Ckey,
                pub function: _rt::String,
            }
            impl ::core::fmt::Debug for Fkey {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Fkey")
                        .field("contract", &self.contract)
                        .field("function", &self.function)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Ekey {
                pub contract: Ckey,
                pub topic: _rt::String,
            }
            impl ::core::fmt::Debug for Ekey {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Ekey")
                        .field("contract", &self.contract)
                        .field("topic", &self.topic)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Okey {
                pub otype: u32,
                pub id: u64,
            }
            impl ::core::fmt::Debug for Okey {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Okey")
                        .field("otype", &self.otype)
                        .field("id", &self.id)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Akey {
                pub atype: _rt::String,
                pub src_id: u64,
                pub tar_id: u64,
            }
            impl ::core::fmt::Debug for Akey {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Akey")
                        .field("atype", &self.atype)
                        .field("src-id", &self.src_id)
                        .field("tar-id", &self.tar_id)
                        .finish()
                }
            }
            /// * core records */
            #[derive(Clone)]
            pub struct Object {
                pub key: Okey,
                pub version: u32,
                pub attributes: Headers,
            }
            impl ::core::fmt::Debug for Object {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Object")
                        .field("key", &self.key)
                        .field("version", &self.version)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Association {
                pub key: Akey,
                pub time: u64,
                pub position: u64,
                pub attributes: Headers,
            }
            impl ::core::fmt::Debug for Association {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Association")
                        .field("key", &self.key)
                        .field("time", &self.time)
                        .field("position", &self.position)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            /// * RPC envelopes */
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct GetObjectRequest {
                pub key: Okey,
            }
            impl ::core::fmt::Debug for GetObjectRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetObjectRequest").field("key", &self.key).finish()
                }
            }
            #[derive(Clone)]
            pub struct GetObjectResponse {
                pub object: Option<Object>,
            }
            impl ::core::fmt::Debug for GetObjectResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetObjectResponse")
                        .field("object", &self.object)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct PutObjectRequest {
                pub object: Object,
            }
            impl ::core::fmt::Debug for PutObjectRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PutObjectRequest")
                        .field("object", &self.object)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct PutObjectResponse {
                pub success: bool,
                pub id: u64,
            }
            impl ::core::fmt::Debug for PutObjectResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PutObjectResponse")
                        .field("success", &self.success)
                        .field("id", &self.id)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RemoveObjectRequest {
                pub key: Okey,
            }
            impl ::core::fmt::Debug for RemoveObjectRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RemoveObjectRequest")
                        .field("key", &self.key)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RemoveObjectResponse {
                pub success: bool,
            }
            impl ::core::fmt::Debug for RemoveObjectResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RemoveObjectResponse")
                        .field("success", &self.success)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CreateAssociationRequest {
                pub association: Association,
            }
            impl ::core::fmt::Debug for CreateAssociationRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CreateAssociationRequest")
                        .field("association", &self.association)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct CreateAssociationResponse {
                pub success: bool,
            }
            impl ::core::fmt::Debug for CreateAssociationResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CreateAssociationResponse")
                        .field("success", &self.success)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct RemoveAssociationRequest {
                pub key: Akey,
            }
            impl ::core::fmt::Debug for RemoveAssociationRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RemoveAssociationRequest")
                        .field("key", &self.key)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RemoveAssociationResponse {
                pub success: bool,
            }
            impl ::core::fmt::Debug for RemoveAssociationResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RemoveAssociationResponse")
                        .field("success", &self.success)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct GetAssociationsRequest {
                pub key: Akey,
                pub above: u64,
                pub limit: u32,
            }
            impl ::core::fmt::Debug for GetAssociationsRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetAssociationsRequest")
                        .field("key", &self.key)
                        .field("above", &self.above)
                        .field("limit", &self.limit)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct GetAssociationsResponse {
                pub associations: _rt::Vec<Association>,
            }
            impl ::core::fmt::Debug for GetAssociationsResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetAssociationsResponse")
                        .field("associations", &self.associations)
                        .finish()
                }
            }
        }
        /// * ───── TAO service ───── */
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod tao {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type GetObjectRequest = super::super::super::brother::guest::common::GetObjectRequest;
            pub type GetObjectResponse = super::super::super::brother::guest::common::GetObjectResponse;
            pub type PutObjectRequest = super::super::super::brother::guest::common::PutObjectRequest;
            pub type PutObjectResponse = super::super::super::brother::guest::common::PutObjectResponse;
            pub type RemoveObjectRequest = super::super::super::brother::guest::common::RemoveObjectRequest;
            pub type RemoveObjectResponse = super::super::super::brother::guest::common::RemoveObjectResponse;
            pub type CreateAssociationRequest = super::super::super::brother::guest::common::CreateAssociationRequest;
            pub type CreateAssociationResponse = super::super::super::brother::guest::common::CreateAssociationResponse;
            pub type RemoveAssociationRequest = super::super::super::brother::guest::common::RemoveAssociationRequest;
            pub type RemoveAssociationResponse = super::super::super::brother::guest::common::RemoveAssociationResponse;
            pub type GetAssociationsRequest = super::super::super::brother::guest::common::GetAssociationsRequest;
            pub type GetAssociationsResponse = super::super::super::brother::guest::common::GetAssociationsResponse;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_object(req: GetObjectRequest) -> GetObjectResponse {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 32 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 32
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let super::super::super::brother::guest::common::GetObjectRequest {
                        key: key0,
                    } = req;
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype1,
                        id: id1,
                    } = key0;
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "get-object"]
                        fn wit_import3(_: i32, _: i64, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(_: i32, _: i64, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import3(_rt::as_i32(otype1), _rt::as_i64(id1), ptr2) };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    let result17 = super::super::super::brother::guest::common::GetObjectResponse {
                        object: match l4 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l5 = *ptr2.add(8).cast::<i32>();
                                    let l6 = *ptr2.add(16).cast::<i64>();
                                    let l7 = *ptr2.add(24).cast::<i32>();
                                    let l8 = *ptr2
                                        .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l9 = *ptr2
                                        .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base16 = l8;
                                    let len16 = l9;
                                    let mut result16 = _rt::Vec::with_capacity(len16);
                                    for i in 0..len16 {
                                        let base = base16
                                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                        let e16 = {
                                            let l10 = *base.add(0).cast::<*mut u8>();
                                            let l11 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len12 = l11;
                                            let bytes12 = _rt::Vec::from_raw_parts(
                                                l10.cast(),
                                                len12,
                                                len12,
                                            );
                                            let l13 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l14 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len15 = l14;
                                            let bytes15 = _rt::Vec::from_raw_parts(
                                                l13.cast(),
                                                len15,
                                                len15,
                                            );
                                            super::super::super::brother::guest::common::Header {
                                                key: _rt::string_lift(bytes12),
                                                value: _rt::string_lift(bytes15),
                                            }
                                        };
                                        result16.push(e16);
                                    }
                                    _rt::cabi_dealloc(
                                        base16,
                                        len16 * (4 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    super::super::super::brother::guest::common::Object {
                                        key: super::super::super::brother::guest::common::Okey {
                                            otype: l5 as u32,
                                            id: l6 as u64,
                                        },
                                        version: l7 as u32,
                                        attributes: result16,
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    };
                    result17
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn put_object(req: &PutObjectRequest) -> PutObjectResponse {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let super::super::super::brother::guest::common::PutObjectRequest {
                        object: object0,
                    } = req;
                    let super::super::super::brother::guest::common::Object {
                        key: key1,
                        version: version1,
                        attributes: attributes1,
                    } = object0;
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype2,
                        id: id2,
                    } = key1;
                    let vec6 = attributes1;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key3,
                                value: value3,
                            } = e;
                            let vec4 = key3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = value3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    }
                    let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "put-object"]
                        fn wit_import8(
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: i32,
                        _: i64,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import8(
                            _rt::as_i32(otype2),
                            _rt::as_i64(id2),
                            _rt::as_i32(version1),
                            result6,
                            len6,
                            ptr7,
                        )
                    };
                    let l9 = i32::from(*ptr7.add(0).cast::<u8>());
                    let l10 = *ptr7.add(8).cast::<i64>();
                    let result11 = super::super::super::brother::guest::common::PutObjectResponse {
                        success: _rt::bool_lift(l9 as u8),
                        id: l10 as u64,
                    };
                    if layout6.size() != 0 {
                        _rt::alloc::dealloc(result6.cast(), layout6);
                    }
                    result11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn remove_object(req: RemoveObjectRequest) -> RemoveObjectResponse {
                unsafe {
                    let super::super::super::brother::guest::common::RemoveObjectRequest {
                        key: key0,
                    } = req;
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype1,
                        id: id1,
                    } = key0;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "remove-object"]
                        fn wit_import2(_: i32, _: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: i32, _: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe {
                        wit_import2(_rt::as_i32(otype1), _rt::as_i64(id1))
                    };
                    super::super::super::brother::guest::common::RemoveObjectResponse {
                        success: _rt::bool_lift(ret as u8),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn create_association(
                req: &CreateAssociationRequest,
            ) -> CreateAssociationResponse {
                unsafe {
                    let super::super::super::brother::guest::common::CreateAssociationRequest {
                        association: association0,
                    } = req;
                    let super::super::super::brother::guest::common::Association {
                        key: key1,
                        time: time1,
                        position: position1,
                        attributes: attributes1,
                    } = association0;
                    let super::super::super::brother::guest::common::Akey {
                        atype: atype2,
                        src_id: src_id2,
                        tar_id: tar_id2,
                    } = key1;
                    let vec3 = atype2;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let vec7 = attributes1;
                    let len7 = vec7.len();
                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec7.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result7 = if layout7.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout7);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec7.into_iter().enumerate() {
                        let base = result7
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key4,
                                value: value4,
                            } = e;
                            let vec5 = key4;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = value4;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr6.cast_mut();
                        }
                    }
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "create-association"]
                        fn wit_import8(
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: i64,
                            _: i64,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i64,
                        _: i64,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe {
                        wit_import8(
                            ptr3.cast_mut(),
                            len3,
                            _rt::as_i64(src_id2),
                            _rt::as_i64(tar_id2),
                            _rt::as_i64(time1),
                            _rt::as_i64(position1),
                            result7,
                            len7,
                        )
                    };
                    if layout7.size() != 0 {
                        _rt::alloc::dealloc(result7.cast(), layout7);
                    }
                    super::super::super::brother::guest::common::CreateAssociationResponse {
                        success: _rt::bool_lift(ret as u8),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn remove_association(
                req: &RemoveAssociationRequest,
            ) -> RemoveAssociationResponse {
                unsafe {
                    let super::super::super::brother::guest::common::RemoveAssociationRequest {
                        key: key0,
                    } = req;
                    let super::super::super::brother::guest::common::Akey {
                        atype: atype1,
                        src_id: src_id1,
                        tar_id: tar_id1,
                    } = key0;
                    let vec2 = atype1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "remove-association"]
                        fn wit_import3(_: *mut u8, _: usize, _: i64, _: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i64,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = unsafe {
                        wit_import3(
                            ptr2.cast_mut(),
                            len2,
                            _rt::as_i64(src_id1),
                            _rt::as_i64(tar_id1),
                        )
                    };
                    super::super::super::brother::guest::common::RemoveAssociationResponse {
                        success: _rt::bool_lift(ret as u8),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_associations(
                req: &GetAssociationsRequest,
            ) -> GetAssociationsResponse {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let super::super::super::brother::guest::common::GetAssociationsRequest {
                        key: key0,
                        above: above0,
                        limit: limit0,
                    } = req;
                    let super::super::super::brother::guest::common::Akey {
                        atype: atype1,
                        src_id: src_id1,
                        tar_id: tar_id1,
                    } = key0;
                    let vec2 = atype1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/tao@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "get-associations"]
                        fn wit_import4(
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: i64,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import4(
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i64,
                        _: i64,
                        _: i32,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import4(
                            ptr2.cast_mut(),
                            len2,
                            _rt::as_i64(src_id1),
                            _rt::as_i64(tar_id1),
                            _rt::as_i64(above0),
                            _rt::as_i32(limit0),
                            ptr3,
                        )
                    };
                    let l5 = *ptr3.add(0).cast::<*mut u8>();
                    let l6 = *ptr3
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base23 = l5;
                    let len23 = l6;
                    let mut result23 = _rt::Vec::with_capacity(len23);
                    for i in 0..len23 {
                        let base = base23
                            .add(i * (32 + 4 * ::core::mem::size_of::<*const u8>()));
                        let e23 = {
                            let l7 = *base.add(0).cast::<*mut u8>();
                            let l8 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            let l10 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l11 = *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l12 = *base
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l13 = *base
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>();
                            let l14 = *base
                                .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *base
                                .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base22 = l14;
                            let len22 = l15;
                            let mut result22 = _rt::Vec::with_capacity(len22);
                            for i in 0..len22 {
                                let base = base22
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                let e22 = {
                                    let l16 = *base.add(0).cast::<*mut u8>();
                                    let l17 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len18 = l17;
                                    let bytes18 = _rt::Vec::from_raw_parts(
                                        l16.cast(),
                                        len18,
                                        len18,
                                    );
                                    let l19 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l20 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len21 = l20;
                                    let bytes21 = _rt::Vec::from_raw_parts(
                                        l19.cast(),
                                        len21,
                                        len21,
                                    );
                                    super::super::super::brother::guest::common::Header {
                                        key: _rt::string_lift(bytes18),
                                        value: _rt::string_lift(bytes21),
                                    }
                                };
                                result22.push(e22);
                            }
                            _rt::cabi_dealloc(
                                base22,
                                len22 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            super::super::super::brother::guest::common::Association {
                                key: super::super::super::brother::guest::common::Akey {
                                    atype: _rt::string_lift(bytes9),
                                    src_id: l10 as u64,
                                    tar_id: l11 as u64,
                                },
                                time: l12 as u64,
                                position: l13 as u64,
                                attributes: result22,
                            }
                        };
                        result23.push(e23);
                    }
                    _rt::cabi_dealloc(
                        base23,
                        len23 * (32 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result24 = super::super::super::brother::guest::common::GetAssociationsResponse {
                        associations: result23,
                    };
                    result24
                }
            }
        }
        /// * ───── host utilities ───── */
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod event_sink {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Object = super::super::super::brother::guest::common::Object;
            #[allow(unused_unsafe, clippy::all)]
            pub fn emit(topic: &str, payload: &Object) -> () {
                unsafe {
                    let vec0 = topic;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let super::super::super::brother::guest::common::Object {
                        key: key1,
                        version: version1,
                        attributes: attributes1,
                    } = payload;
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype2,
                        id: id2,
                    } = key1;
                    let vec6 = attributes1;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key3,
                                value: value3,
                            } = e;
                            let vec4 = key3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = value3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    }
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/event-sink@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "emit"]
                        fn wit_import7(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import7(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i64,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import7(
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i32(otype2),
                            _rt::as_i64(id2),
                            _rt::as_i32(version1),
                            result6,
                            len6,
                        )
                    };
                    if layout6.size() != 0 {
                        _rt::alloc::dealloc(result6.cast(), layout6);
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod pubsub {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Ekey = super::super::super::brother::guest::common::Ekey;
            pub type Fkey = super::super::super::brother::guest::common::Fkey;
            pub type Akey = super::super::super::brother::guest::common::Akey;
            pub type SubId = super::super::super::brother::guest::common::SubId;
            #[allow(unused_unsafe, clippy::all)]
            pub fn subscribe(source: &Ekey, target: &Fkey, argument: &Akey) -> SubId {
                unsafe {
                    let super::super::super::brother::guest::common::Ekey {
                        contract: contract0,
                        topic: topic0,
                    } = source;
                    let super::super::super::brother::guest::common::Ckey { id: id1 } = contract0;
                    let vec2 = topic0;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let super::super::super::brother::guest::common::Fkey {
                        contract: contract3,
                        function: function3,
                    } = target;
                    let super::super::super::brother::guest::common::Ckey { id: id4 } = contract3;
                    let vec5 = function3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    let super::super::super::brother::guest::common::Akey {
                        atype: atype6,
                        src_id: src_id6,
                        tar_id: tar_id6,
                    } = argument;
                    let vec7 = atype6;
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/pubsub@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "subscribe"]
                        fn wit_import8(
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: i64,
                        ) -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: i64,
                    ) -> i64 {
                        unreachable!()
                    }
                    let ret = unsafe {
                        wit_import8(
                            _rt::as_i64(id1),
                            ptr2.cast_mut(),
                            len2,
                            _rt::as_i64(id4),
                            ptr5.cast_mut(),
                            len5,
                            ptr7.cast_mut(),
                            len7,
                            _rt::as_i64(src_id6),
                            _rt::as_i64(tar_id6),
                        )
                    };
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn unsubscribe(id: SubId) -> () {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/pubsub@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "unsubscribe"]
                        fn wit_import0(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import0(_: i64) {
                        unreachable!()
                    }
                    unsafe { wit_import0(_rt::as_i64(id)) };
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod scheduler {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Fkey = super::super::super::brother::guest::common::Fkey;
            pub type Okey = super::super::super::brother::guest::common::Okey;
            #[allow(unused_unsafe, clippy::all)]
            pub fn schedule(repeater: &str, target: &Fkey, argument: Okey) -> () {
                unsafe {
                    let vec0 = repeater;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let super::super::super::brother::guest::common::Fkey {
                        contract: contract1,
                        function: function1,
                    } = target;
                    let super::super::super::brother::guest::common::Ckey { id: id2 } = contract1;
                    let vec3 = function1;
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype4,
                        id: id4,
                    } = argument;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/scheduler@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "schedule"]
                        fn wit_import5(
                            _: *mut u8,
                            _: usize,
                            _: i64,
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import5(
                        _: *mut u8,
                        _: usize,
                        _: i64,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i64,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import5(
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i64(id2),
                            ptr3.cast_mut(),
                            len3,
                            _rt::as_i32(otype4),
                            _rt::as_i64(id4),
                        )
                    };
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod inference {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Object = super::super::super::brother::guest::common::Object;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum InferError {
                ModelNotFound,
                InvalidInput,
                Internal,
            }
            impl InferError {
                pub fn name(&self) -> &'static str {
                    match self {
                        InferError::ModelNotFound => "MODEL-NOT-FOUND",
                        InferError::InvalidInput => "INVALID-INPUT",
                        InferError::Internal => "INTERNAL",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        InferError::ModelNotFound => "",
                        InferError::InvalidInput => "",
                        InferError::Internal => "",
                    }
                }
            }
            impl ::core::fmt::Debug for InferError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("InferError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for InferError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for InferError {}
            impl InferError {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> InferError {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => InferError::ModelNotFound,
                        1 => InferError::InvalidInput,
                        2 => InferError::Internal,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn infer(model: &str, input: &Object) -> Result<Object, InferError> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 32 + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 32
                            + 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = model;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let super::super::super::brother::guest::common::Object {
                        key: key1,
                        version: version1,
                        attributes: attributes1,
                    } = input;
                    let super::super::super::brother::guest::common::Okey {
                        otype: otype2,
                        id: id2,
                    } = key1;
                    let vec6 = attributes1;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key3,
                                value: value3,
                            } = e;
                            let vec4 = key3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = value3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    }
                    let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/inference@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "infer"]
                        fn wit_import8(
                            _: *mut u8,
                            _: usize,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import8(
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i64,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import8(
                            ptr0.cast_mut(),
                            len0,
                            _rt::as_i32(otype2),
                            _rt::as_i64(id2),
                            _rt::as_i32(version1),
                            result6,
                            len6,
                            ptr7,
                        )
                    };
                    let l9 = i32::from(*ptr7.add(0).cast::<u8>());
                    let result23 = match l9 {
                        0 => {
                            let e = {
                                let l10 = *ptr7.add(8).cast::<i32>();
                                let l11 = *ptr7.add(16).cast::<i64>();
                                let l12 = *ptr7.add(24).cast::<i32>();
                                let l13 = *ptr7
                                    .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l14 = *ptr7
                                    .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base21 = l13;
                                let len21 = l14;
                                let mut result21 = _rt::Vec::with_capacity(len21);
                                for i in 0..len21 {
                                    let base = base21
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e21 = {
                                        let l15 = *base.add(0).cast::<*mut u8>();
                                        let l16 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 = _rt::Vec::from_raw_parts(
                                            l15.cast(),
                                            len17,
                                            len17,
                                        );
                                        let l18 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l19 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len20 = l19;
                                        let bytes20 = _rt::Vec::from_raw_parts(
                                            l18.cast(),
                                            len20,
                                            len20,
                                        );
                                        super::super::super::brother::guest::common::Header {
                                            key: _rt::string_lift(bytes17),
                                            value: _rt::string_lift(bytes20),
                                        }
                                    };
                                    result21.push(e21);
                                }
                                _rt::cabi_dealloc(
                                    base21,
                                    len21 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                super::super::super::brother::guest::common::Object {
                                    key: super::super::super::brother::guest::common::Okey {
                                        otype: l10 as u32,
                                        id: l11 as u64,
                                    },
                                    version: l12 as u32,
                                    attributes: result21,
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l22 = i32::from(*ptr7.add(8).cast::<u8>());
                                InferError::_lift(l22 as u8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout6.size() != 0 {
                        _rt::alloc::dealloc(result6.cast(), layout6);
                    }
                    result23
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod http {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Headers = super::super::super::brother::guest::common::Headers;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum Method {
                Get,
                Post,
                Put,
                Delete,
                Patch,
                Head,
                Options,
            }
            impl ::core::fmt::Debug for Method {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Method::Get => f.debug_tuple("Method::Get").finish(),
                        Method::Post => f.debug_tuple("Method::Post").finish(),
                        Method::Put => f.debug_tuple("Method::Put").finish(),
                        Method::Delete => f.debug_tuple("Method::Delete").finish(),
                        Method::Patch => f.debug_tuple("Method::Patch").finish(),
                        Method::Head => f.debug_tuple("Method::Head").finish(),
                        Method::Options => f.debug_tuple("Method::Options").finish(),
                    }
                }
            }
            impl Method {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Method {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Method::Get,
                        1 => Method::Post,
                        2 => Method::Put,
                        3 => Method::Delete,
                        4 => Method::Patch,
                        5 => Method::Head,
                        6 => Method::Options,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[derive(Clone)]
            pub struct Request {
                pub method: Method,
                pub url: _rt::String,
                pub headers: Headers,
                pub body: Headers,
            }
            impl ::core::fmt::Debug for Request {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("method", &self.method)
                        .field("url", &self.url)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Response {
                pub status: u16,
                pub headers: Headers,
                pub body: _rt::String,
            }
            impl ::core::fmt::Debug for Response {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Response")
                        .field("status", &self.status)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum HttpError {
                Network,
                Timeout,
                Dns,
                Tls,
                Internal,
            }
            impl HttpError {
                pub fn name(&self) -> &'static str {
                    match self {
                        HttpError::Network => "NETWORK",
                        HttpError::Timeout => "TIMEOUT",
                        HttpError::Dns => "DNS",
                        HttpError::Tls => "TLS",
                        HttpError::Internal => "INTERNAL",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        HttpError::Network => "",
                        HttpError::Timeout => "",
                        HttpError::Dns => "",
                        HttpError::Tls => "",
                        HttpError::Internal => "",
                    }
                }
            }
            impl ::core::fmt::Debug for HttpError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HttpError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for HttpError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{} (error {})", self.name(), * self as i32)
                }
            }
            impl std::error::Error for HttpError {}
            impl HttpError {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> HttpError {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => HttpError::Network,
                        1 => HttpError::Timeout,
                        2 => HttpError::Dns,
                        3 => HttpError::Tls,
                        4 => HttpError::Internal,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn fetch(req: &Request) -> Result<Response, HttpError> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 6 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 6
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let Request {
                        method: method0,
                        url: url0,
                        headers: headers0,
                        body: body0,
                    } = req;
                    let vec1 = url0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec5 = headers0;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key2,
                                value: value2,
                            } = e;
                            let vec3 = key2;
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = value2;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    }
                    let vec9 = body0;
                    let len9 = vec9.len();
                    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec9.len() * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result9 = if layout9.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout9);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec9.into_iter().enumerate() {
                        let base = result9
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let super::super::super::brother::guest::common::Header {
                                key: key6,
                                value: value6,
                            } = e;
                            let vec7 = key6;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                            let vec8 = value6;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    }
                    let ptr10 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "brother:guest/http@1.6.0")]
                    unsafe extern "C" {
                        #[link_name = "fetch"]
                        fn wit_import11(
                            _: i32,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import11(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import11(
                            method0.clone() as i32,
                            ptr1.cast_mut(),
                            len1,
                            result5,
                            len5,
                            result9,
                            len9,
                            ptr10,
                        )
                    };
                    let l12 = i32::from(*ptr10.add(0).cast::<u8>());
                    let result27 = match l12 {
                        0 => {
                            let e = {
                                let l13 = i32::from(
                                    *ptr10
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<u16>(),
                                );
                                let l14 = *ptr10
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l15 = *ptr10
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base22 = l14;
                                let len22 = l15;
                                let mut result22 = _rt::Vec::with_capacity(len22);
                                for i in 0..len22 {
                                    let base = base22
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e22 = {
                                        let l16 = *base.add(0).cast::<*mut u8>();
                                        let l17 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len18 = l17;
                                        let bytes18 = _rt::Vec::from_raw_parts(
                                            l16.cast(),
                                            len18,
                                            len18,
                                        );
                                        let l19 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l20 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len21 = l20;
                                        let bytes21 = _rt::Vec::from_raw_parts(
                                            l19.cast(),
                                            len21,
                                            len21,
                                        );
                                        super::super::super::brother::guest::common::Header {
                                            key: _rt::string_lift(bytes18),
                                            value: _rt::string_lift(bytes21),
                                        }
                                    };
                                    result22.push(e22);
                                }
                                _rt::cabi_dealloc(
                                    base22,
                                    len22 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                let l23 = *ptr10
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l24 = *ptr10
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len25 = l24;
                                let bytes25 = _rt::Vec::from_raw_parts(
                                    l23.cast(),
                                    len25,
                                    len25,
                                );
                                Response {
                                    status: l13 as u16,
                                    headers: result22,
                                    body: _rt::string_lift(bytes25),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l26 = i32::from(
                                    *ptr10.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                                );
                                HttpError::_lift(l26 as u8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    };
                    if layout5.size() != 0 {
                        _rt::alloc::dealloc(result5.cast(), layout5);
                    }
                    if layout9.size() != 0 {
                        _rt::alloc::dealloc(result9.cast(), layout9);
                    }
                    result27
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod brother {
        pub mod guest {
            /// * ───── contract entrypoint ───── */
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod contract {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Headers = super::super::super::super::brother::guest::common::Headers;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_deploy_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let base6 = arg0;
                    let len6 = arg1;
                    let mut result6 = _rt::Vec::with_capacity(len6);
                    for i in 0..len6 {
                        let base = base6
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e6 = {
                            let l0 = *base.add(0).cast::<*mut u8>();
                            let l1 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len2 = l1;
                            let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                            let l3 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            super::super::super::super::brother::guest::common::Header {
                                key: _rt::string_lift(bytes2),
                                value: _rt::string_lift(bytes5),
                            }
                        };
                        result6.push(e6);
                    }
                    _rt::cabi_dealloc(
                        base6,
                        len6 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    T::deploy(result6);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_render_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::render(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_render<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base7 = arg2;
                    let len7 = arg3;
                    let mut result7 = _rt::Vec::with_capacity(len7);
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e7 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len3 = l2;
                            let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                            let l4 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            super::super::super::super::brother::guest::common::Header {
                                key: _rt::string_lift(bytes3),
                                value: _rt::string_lift(bytes6),
                            }
                        };
                        result7.push(e7);
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = T::invoke(_rt::string_lift(bytes0), result7);
                    let ptr9 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result8 {
                        Ok(e) => {
                            *ptr9.add(0).cast::<u8>() = (0i32) as u8;
                            let vec13 = e;
                            let len13 = vec13.len();
                            let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec13.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result13 = if layout13.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout13);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec13.into_iter().enumerate() {
                                let base = result13
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::brother::guest::common::Header {
                                        key: key10,
                                        value: value10,
                                    } = e;
                                    let vec11 = (key10.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                                    let vec12 = (value10.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr12.cast_mut();
                                }
                            }
                            *ptr9
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len13;
                            *ptr9.add(8).cast::<*mut u8>() = result13;
                        }
                        Err(e) => {
                            *ptr9.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr9.add(8).cast::<i64>() = _rt::as_i64(e);
                        }
                    };
                    ptr9
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_invoke<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base7 = l1;
                            let len7 = l2;
                            for i in 0..len7 {
                                let base = base7
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base7,
                                len7 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {}
                    }
                }
                pub trait Guest {
                    fn deploy(payload: Headers) -> ();
                    fn render(routing: _rt::String) -> _rt::String;
                    fn invoke(
                        method: _rt::String,
                        payload: Headers,
                    ) -> Result<Headers, u64>;
                }
                #[doc(hidden)]
                macro_rules! __export_brother_guest_contract_1_6_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "brother:guest/contract@1.6.0#deploy")] unsafe extern "C" fn
                        export_deploy(arg0 : * mut u8, arg1 : usize,) { unsafe {
                        $($path_to_types)*:: _export_deploy_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name = "brother:guest/contract@1.6.0#render")]
                        unsafe extern "C" fn export_render(arg0 : * mut u8, arg1 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_render_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name = "cabi_post_brother:guest/contract@1.6.0#render")]
                        unsafe extern "C" fn _post_return_render(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_render::<$ty > (arg0)
                        } } #[unsafe (export_name =
                        "brother:guest/contract@1.6.0#invoke")] unsafe extern "C" fn
                        export_invoke(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8,
                        arg3 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_invoke_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name = "cabi_post_brother:guest/contract@1.6.0#invoke")]
                        unsafe extern "C" fn _post_return_invoke(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_invoke::<$ty > (arg0)
                        } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_brother_guest_contract_1_6_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 8 + 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8
                        + 2 * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::alloc;
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_demo_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::brother::guest::contract::__export_brother_guest_contract_1_6_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::brother::guest::contract);
    };
}
#[doc(inline)]
pub(crate) use __export_demo_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:brother:guest@1.6.0:demo:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2995] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb8\x16\x01A\x02\x01\
A$\x01B4\x01s\x04\0\x06signer\x03\0\0\x01p\x01\x04\0\x0bmultisigner\x03\0\x02\x01\
s\x04\0\x06digest\x03\0\x04\x01r\x02\x03keys\x05values\x04\0\x06header\x03\0\x06\
\x01p\x07\x04\0\x07headers\x03\0\x08\x01w\x04\0\x06sub-id\x03\0\x0a\x01r\x01\x02\
idw\x04\0\x04ckey\x03\0\x0c\x01r\x02\x08contract\x0d\x08functions\x04\0\x04fkey\x03\
\0\x0e\x01r\x02\x08contract\x0d\x05topics\x04\0\x04ekey\x03\0\x10\x01r\x02\x05ot\
ypey\x02idw\x04\0\x04okey\x03\0\x12\x01r\x03\x05atypes\x06src-idw\x06tar-idw\x04\
\0\x04akey\x03\0\x14\x01r\x03\x03key\x13\x07versiony\x0aattributes\x09\x04\0\x06\
object\x03\0\x16\x01r\x04\x03key\x15\x04timew\x08positionw\x0aattributes\x09\x04\
\0\x0bassociation\x03\0\x18\x01r\x01\x03key\x13\x04\0\x12get-object-request\x03\0\
\x1a\x01k\x17\x01r\x01\x06object\x1c\x04\0\x13get-object-response\x03\0\x1d\x01r\
\x01\x06object\x17\x04\0\x12put-object-request\x03\0\x1f\x01r\x02\x07success\x7f\
\x02idw\x04\0\x13put-object-response\x03\0!\x01r\x01\x03key\x13\x04\0\x15remove-\
object-request\x03\0#\x01r\x01\x07success\x7f\x04\0\x16remove-object-response\x03\
\0%\x01r\x01\x0bassociation\x19\x04\0\x1acreate-association-request\x03\0'\x01r\x01\
\x07success\x7f\x04\0\x1bcreate-association-response\x03\0)\x01r\x01\x03key\x15\x04\
\0\x1aremove-association-request\x03\0+\x01r\x01\x07success\x7f\x04\0\x1bremove-\
association-response\x03\0-\x01r\x03\x03key\x15\x05abovew\x05limity\x04\0\x18get\
-associations-request\x03\0/\x01p\x19\x01r\x01\x0cassociations1\x04\0\x19get-ass\
ociations-response\x03\02\x03\0\x1abrother:guest/common@1.6.0\x05\0\x02\x03\0\0\x12\
get-object-request\x02\x03\0\0\x13get-object-response\x02\x03\0\0\x12put-object-\
request\x02\x03\0\0\x13put-object-response\x02\x03\0\0\x15remove-object-request\x02\
\x03\0\0\x16remove-object-response\x02\x03\0\0\x1acreate-association-request\x02\
\x03\0\0\x1bcreate-association-response\x02\x03\0\0\x1aremove-association-reques\
t\x02\x03\0\0\x1bremove-association-response\x02\x03\0\0\x18get-associations-req\
uest\x02\x03\0\0\x19get-associations-response\x01B$\x02\x03\x02\x01\x01\x04\0\x12\
get-object-request\x03\0\0\x02\x03\x02\x01\x02\x04\0\x13get-object-response\x03\0\
\x02\x02\x03\x02\x01\x03\x04\0\x12put-object-request\x03\0\x04\x02\x03\x02\x01\x04\
\x04\0\x13put-object-response\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x15remove-obje\
ct-request\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x16remove-object-response\x03\0\x0a\
\x02\x03\x02\x01\x07\x04\0\x1acreate-association-request\x03\0\x0c\x02\x03\x02\x01\
\x08\x04\0\x1bcreate-association-response\x03\0\x0e\x02\x03\x02\x01\x09\x04\0\x1a\
remove-association-request\x03\0\x10\x02\x03\x02\x01\x0a\x04\0\x1bremove-associa\
tion-response\x03\0\x12\x02\x03\x02\x01\x0b\x04\0\x18get-associations-request\x03\
\0\x14\x02\x03\x02\x01\x0c\x04\0\x19get-associations-response\x03\0\x16\x01@\x01\
\x03req\x01\0\x03\x04\0\x0aget-object\x01\x18\x01@\x01\x03req\x05\0\x07\x04\0\x0a\
put-object\x01\x19\x01@\x01\x03req\x09\0\x0b\x04\0\x0dremove-object\x01\x1a\x01@\
\x01\x03req\x0d\0\x0f\x04\0\x12create-association\x01\x1b\x01@\x01\x03req\x11\0\x13\
\x04\0\x12remove-association\x01\x1c\x01@\x01\x03req\x15\0\x17\x04\0\x10get-asso\
ciations\x01\x1d\x03\0\x17brother:guest/tao@1.6.0\x05\x0d\x02\x03\0\0\x06object\x01\
B\x04\x02\x03\x02\x01\x0e\x04\0\x06object\x03\0\0\x01@\x02\x05topics\x07payload\x01\
\x01\0\x04\0\x04emit\x01\x02\x03\0\x1ebrother:guest/event-sink@1.6.0\x05\x0f\x02\
\x03\0\0\x04ekey\x02\x03\0\0\x04fkey\x02\x03\0\0\x04akey\x02\x03\0\0\x06sub-id\x01\
B\x0c\x02\x03\x02\x01\x10\x04\0\x04ekey\x03\0\0\x02\x03\x02\x01\x11\x04\0\x04fke\
y\x03\0\x02\x02\x03\x02\x01\x12\x04\0\x04akey\x03\0\x04\x02\x03\x02\x01\x13\x04\0\
\x06sub-id\x03\0\x06\x01@\x03\x06source\x01\x06target\x03\x08argument\x05\0\x07\x04\
\0\x09subscribe\x01\x08\x01@\x01\x02id\x07\x01\0\x04\0\x0bunsubscribe\x01\x09\x03\
\0\x1abrother:guest/pubsub@1.6.0\x05\x14\x02\x03\0\0\x04okey\x01B\x06\x02\x03\x02\
\x01\x11\x04\0\x04fkey\x03\0\0\x02\x03\x02\x01\x15\x04\0\x04okey\x03\0\x02\x01@\x03\
\x08repeaters\x06target\x01\x08argument\x03\x01\0\x04\0\x08schedule\x01\x04\x03\0\
\x1dbrother:guest/scheduler@1.6.0\x05\x16\x01B\x07\x02\x03\x02\x01\x0e\x04\0\x06\
object\x03\0\0\x01m\x03\x0fMODEL-NOT-FOUND\x0dINVALID-INPUT\x08INTERNAL\x04\0\x0b\
infer-error\x03\0\x02\x01j\x01\x01\x01\x03\x01@\x02\x05models\x05input\x01\0\x04\
\x04\0\x05infer\x01\x05\x03\0\x1dbrother:guest/inference@1.6.0\x05\x17\x02\x03\0\
\0\x07headers\x01B\x0d\x02\x03\x02\x01\x18\x04\0\x07headers\x03\0\0\x01m\x07\x03\
GET\x04POST\x03PUT\x06DELETE\x05PATCH\x04HEAD\x07OPTIONS\x04\0\x06method\x03\0\x02\
\x01r\x04\x06method\x03\x03urls\x07headers\x01\x04body\x01\x04\0\x07request\x03\0\
\x04\x01r\x03\x06status{\x07headers\x01\x04bodys\x04\0\x08response\x03\0\x06\x01\
m\x05\x07NETWORK\x07TIMEOUT\x03DNS\x03TLS\x08INTERNAL\x04\0\x0ahttp-error\x03\0\x08\
\x01j\x01\x07\x01\x09\x01@\x01\x03req\x05\0\x0a\x04\0\x05fetch\x01\x0b\x03\0\x18\
brother:guest/http@1.6.0\x05\x19\x02\x03\0\0\x06signer\x01B\x0b\x02\x03\x02\x01\x1a\
\x04\0\x06signer\x03\0\0\x02\x03\x02\x01\x18\x04\0\x07headers\x03\0\x02\x01@\x01\
\x07payload\x03\x01\0\x04\0\x06deploy\x01\x04\x01@\x01\x07routings\0s\x04\0\x06r\
ender\x01\x05\x01j\x01\x03\x01w\x01@\x02\x06methods\x07payload\x03\0\x06\x04\0\x06\
invoke\x01\x07\x04\0\x1cbrother:guest/contract@1.6.0\x05\x1b\x04\0\x18brother:gu\
est/demo@1.6.0\x04\0\x0b\x0a\x01\0\x04demo\x03\0\0\0G\x09producers\x01\x0cproces\
sed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
